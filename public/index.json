[{"content":"Why Often forget the password Use a long random password to enhance security Easy to connect Qr Code Format WIFI:T:WPA;S:\u0026lt;SSID\u0026gt;;P:\u0026lt;PASSWORD\u0026gt;;; Minimum OS Requirements Android 10 IOS 11 ","permalink":"http://localhost:1313/posts/use-qrcode-to-display-wifi-password/","summary":"Use Qr Code to Display Wifi Password","title":"Use Qr Code to Display Wifi Password"},{"content":"添加远程模板仓库 git remote add template [template repo url] 拉取所有更新 git fetch --all 与远程仓库模板的指定分支合并 git merge template/[branch name] # 如果有报错`fatal: refusing to merge unrelated histories`，请加上`--allow-unrelated-histories` Managing remote repositories - GitHub Docs\n","permalink":"http://localhost:1313/posts/add-git-template-for-a-project/","summary":"为项目添加 git template，并从远程仓库拉取更新","title":"为项目添加 git template，并从远程仓库拉取更新"},{"content":"原因 因为国内无法直接访问 openai，openai 也不支持国内区域。部署后，可以让朋友们一起使用，免去了一些复杂过程。\nOpenCat OpenCat on the App Store\n一款 ChatGPT 客户端，支持 mac 和 iOS 支持 docker私有部署，部署后可以分享给朋友使用 Fly.io 免费计划可以使用 3 个共享 cpu 的虚拟机，3GB 储存和 160GB 下行数据，足够支持我们部署后的使用 准备 至少一个 openai 的 key，多个可以轮询 Fly.io 账号 若要使用微软 TTS 功能，需要 Azure 账号 私有部署 1. 配置文件 使用𝔽𝕣𝕠𝕤𝕥 𝕄𝕚𝕟𝕘分享的配置\nkill_signal = \u0026#34;SIGINT\u0026#34; kill_timeout = 5 primary_region = \u0026#34;sin\u0026#34; processes = [] [build] image = \u0026#34;bayedev/opencatd\u0026#34; [mount] source = \u0026#34;opencat\u0026#34; destination = \u0026#34;/opt/db\u0026#34; [experimental] auto_rollback = true [[services]] internal_port = 80 protocol = \u0026#34;tcp\u0026#34; [services.concurrency] hard_limit = 25 soft_limit = 20 type = \u0026#34;connections\u0026#34; [[services.ports]] force_https = true handlers = [\u0026#34;http\u0026#34;] port = 80 [[services.ports]] handlers = [\u0026#34;tls\u0026#34;, \u0026#34;http\u0026#34;] port = 443 [[services.tcp_checks]] grace_period = \u0026#34;1s\u0026#34; interval = \u0026#34;15s\u0026#34; restart_limit = 0 timeout = \u0026#34;2s\u0026#34; 2. 安装 fly 的命令行工具 Install flyctl · Fly Docs\n#Mac brew install flyctl #Linux curl -L https://fly.io/install.sh | sh #Windows powershell -Command \u0026#34;iwr https://fly.io/install.ps1 -useb | iex\u0026#34; 3. 登录 fly fly auth login 4. 本地建立目录，创建 fly.tomal 文件并复制上面的配置内容 5. 创建和部署 App 创建的区域节点尽量选择美国的\nfly launch --copy-config fly vol create opencat --size 1 fly deploy 6. 绑定域名 Fly.io 提供 SSL 证书，在 dashboard 中配置一下\n7. 在 OpenCat 中配置 在 OpenCat 中创建团队，填入绑上的域名，填上 openai 的 key 就能直接使用了 若要使用微软的 TTS，登录 Azure 后，创建语音资源，在 OpenCat 配置中选择区域，填上 token ","permalink":"http://localhost:1313/posts/deploy-opencat-for-team-in-fly-io/","summary":"使用 Fly.io 部署 OpenCat for Team","title":"使用 Fly.io 部署 OpenCat for Team"},{"content":"安装指南 官方指南\n注意步骤 第三步 Install Pip and installing NumPy with Pip 第六步 Set Bazel variables #If installed Microsoft Visual Studio 2019 Professional BAZEL_VS=C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional BAZEL_VC=C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC find BAZEL_VC_FULL_VERSION on path C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC find BAZEL_WINSDK_FULL_VERSION on path C:\\Program Files (x86)\\Windows Kits\\10\\Include 遇到的问题 can not open “windows.h”: No such file or directory Install windows 10 sdk and rename Windows.h to windows.h\nPath of \u0026ldquo;Windows.h\u0026rdquo; is C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\um\nbuilding with VPN build with \u0026ndash;batch tag\nhttps://github.com/bazelbuild/bazel/issues/3602\n","permalink":"http://localhost:1313/posts/install-media-pipe-on-windows/","summary":"在 Windows 上安装 MediaPipe","title":"在 Windows 上安装 MediaPipe"},{"content":"React Datepicker\nimport DatePicker, { registerLocale } from \u0026#34;react-datepicker\u0026#34;; import zhCN from \u0026#34;date-fns/locale/zh-CN\u0026#34;; // the locale you want registerLocale(\u0026#34;zhCN\u0026#34;, zhCN); \u0026lt;DatePicker dateFormat=\u0026#34;yyyy-MM-dd\u0026#34; locale=\u0026#34;zhCN\u0026#34; ... /\u0026gt; ","permalink":"http://localhost:1313/posts/react-datepicker-set-zh/","summary":"React Datepicker 设置中文","title":"React Datepicker 设置中文"},{"content":"官网 与 Redux 配合使用，解决使用 Redux 时，配置繁琐和模板代码太多的问题。\n使用心得 Usage With TypeScript export const store = configureStore({ ... }); export type RootState = ReturnType\u0026lt;typeof store.getState\u0026gt; export type AppDispatch = typeof store.dispatch export const useAppDispatch = () =\u0026gt; useDispatch\u0026lt;AppDispatch\u0026gt;() export const useAppSelector: TypedUseSelectorHook\u0026lt;RootState\u0026gt; = useSelector RTK Query 获取和缓存数据\nCode Splitting 分割代码，规范代码结构，减少模板代码\n数据持久化 1. Persistence and Rehydration 2. Redux Persist const persistConfig = { key: \u0026#34;root\u0026#34;, storage, whitelist: [\u0026#34;auth\u0026#34;, \u0026#34;router\u0026#34;], }; export const store = configureStore({ reducer: persistReducer( persistConfig, combineReducers({ auth: authReducer, router: routerReducer, district: districtReducer, [authApi.reducerPath]: authApi.reducer, [userApi.reducerPath]: userApi.reducer, }) ), middleware: (getDefaultMiddleware) =\u0026gt; getDefaultMiddleware({ serializableCheck: false }).concat( authApi.middleware, userApi.middleware ), }); export const persist = persistStore(store); 3. Queries import { createApi, fetchBaseQuery } from \u0026#34;@reduxjs/toolkit/query/react\u0026#34;; //使用 Hook 一定要导入这个包 4. Customizing queries 自己实现一个 baseQuery 就可以添加 header，解析自定义返回值和异常处理\nconst myFetchBaseQuery: BaseQueryFn\u0026lt; string | FetchArgs, unknown, FetchBaseQueryError, {}, FetchBaseQueryMeta \u0026gt; = async (args, api, extraOptions) =\u0026gt; { const result = await fetchBaseQuery({ baseUrl: apiUrl, prepareHeaders: (headers, { getState }) =\u0026gt; { const token = (getState() as RootState).auth.token; if (token) { headers.set(\u0026#34;authorization\u0026#34;, `Bearer ${token}`); } return headers; }, })(args, api, extraOptions); return new Promise\u0026lt;any\u0026gt;((resolve, reject) =\u0026gt; { let response: Result\u0026lt;any\u0026gt;; const { error } = result; if (error) { response = error.data as Result\u0026lt;any\u0026gt;; } else { response = result.data as unknown as Result\u0026lt;any\u0026gt;; } const { data, code, msg } = response; if (code \u0026gt;= 200 \u0026amp;\u0026amp; code \u0026lt; 300) { result.data = data; resolve(result); } else { showError(msg ?? \u0026#34;\u0026#34;); reject(msg); } }); }; ","permalink":"http://localhost:1313/posts/use-redux-toolkit/","summary":"Redux Toolkit 使用笔记","title":"Redux Toolkit 使用笔记"},{"content":"起因 新建项目，运行后报错“Failed to start bean \u0026lsquo;documentationPluginsBootstrapper\u0026rsquo;;”。面向搜索引擎编程，看了Springboot 2.6.0 / Spring fox 3 - Failed to start bean \u0026lsquo;documentationPluginsBootstrapper\u0026rsquo;，说是 a bug in SpringFox，查了下包也没有新的。看了采纳的回答“Consider migration to springdoc”。\n解决 官方指南，看这个就够了。springdoc-openapi v1.6.8\n","permalink":"http://localhost:1313/posts/use-spring-doc-instead-of-spring-fox/","summary":"Use Spring Doc instead of Spring Fox","title":"Use Spring Doc instead of Spring Fox"},{"content":"需求 有两个项目，使用相同的 UI、api，想用一套通用的代码解决问题。 这套通用的代码也在逐步完善，经常需要改动。 解决方案 使用 npm link，把这套通用代码项目创建一个全局的链接，然后在那两个项目中链接。\n更新方案\n使用 git template，把这套通用代码项目创建一个模板，然后在那两个项目中引用。\n示例 准备 有两个项目 demo 和 demo-common，需要在 demo 中 link demo-common\n步骤 在 demo-common 项目中执行 npm link，创建全局链接，可以在全局的 node_modules 文件夹中看到项目的快捷方式。 然后在 demo 项目中执行 npm link demo-common，就已链接完成。 注意，npm link 的是包名，不是文件夹名称。 参考 npm-link | npm Docs (npmjs.com)\n","permalink":"http://localhost:1313/posts/import-local-project-using-npm-link/","summary":"使用 npm link 引入本地项目","title":"使用 npm link 引入本地项目"},{"content":"Steps 1. Config in SpringBootApplication. Set the scanning base packages //find all repositories extending JpaRepository in the packages @EnableJpaRepositories(basePackages = \u0026#34;com.base\u0026#34;) //find all entities in the packages @EntityScan(basePackages = \u0026#34;com.base\u0026#34;) @SpringBootApplication(scanBasePackages = \u0026#34;com.base\u0026#34;) public class CoreApplication { public static void main(String[] args) { SpringApplication.run(CoreApplication.class, args); } } 2. Config in gradle. When using the modules, Spring Boot will match urls for them. Check log in the console dependencies { implementation(project(\u0026#34;:cloud-service\u0026#34;)) implementation(project(\u0026#34;:common\u0026#34;)) implementation(project(\u0026#34;:wechat\u0026#34;)) } ","permalink":"http://localhost:1313/posts/config-spring-boot-multi-module-with-jpa/","summary":"Config Spring Boot Multi Module With Jpa","title":"Config Spring Boot Multi Module With Jpa"},{"content":" Copy a List to Another List in Java\n1. Constructor List\u0026lt;T\u0026gt; copy = new ArrayList\u0026lt;\u0026gt;(list); 2. AddAll List\u0026lt;T\u0026gt; copy = new ArrayList\u0026lt;\u0026gt;(); copy.addAll(list); 3. Collections.copy List\u0026lt;Integer\u0026gt; source = Arrays.asList(1, 2, 3); List\u0026lt;Integer\u0026gt; dest = Arrays.asList(5, 6, 7, 8, 9, 10); Collections.copy(dest, source); 4. Using Stream in Java 8 List\u0026lt;String\u0026gt; copy = list.stream().collect(Collectors.toList()); 5. In Java 10 List\u0026lt;T\u0026gt; copy = List.copyOf(list); ","permalink":"http://localhost:1313/posts/copy-a-list-to-another-list-in-java/","summary":"Copy a List to Another List in Java","title":"Copy a List to Another List in Java"},{"content":"4 种构造函数 ///普通构造函数 ClassName(...) ///命名构造函数 Classname.identifier(...) ///常量构造函数 const ClassName(...) ///工厂构造函数 factroy ClassName(...) 默认构造函数 类没有定义构造函数，默认有一个没有参数的构造函数\n普通构造函数 命名构造函数 初始化列表 初始化列表就是构造函数名的冒号后的部分 尤其是初始化那些 final 修饰的成员变量时，初始化列表很有用 工厂构造函数，没有权利访问 this\n参考 Dart 构造函数介绍 Colon : in Dart constructor syntax ","permalink":"http://localhost:1313/posts/dart-constructor/","summary":"Dart 的构造函数","title":"Dart 的构造函数"},{"content":"(De)Serialization @JsonSerializable to label classes which can be serialized @JsonKey to provide string representations of field names @JsonValue to provide string representations of field values Implement JSONConverter to convert object representations into JSON representations ","permalink":"http://localhost:1313/posts/serialization-and-deserialization-of-flutter/","summary":"Flutter 的序列化和反序列化","title":"Flutter 的序列化和反序列化"},{"content":" Spring Data JPA - Interface-based Projections\nInterface-based Projections 1. Entity @Entity public class Employee{ private @Id @GeneratedValue Long id; private String name; private String dept; private int salary; ............. } 2. Projection Interface public interface EmployeeSalary { String getName(); int getSalary(); } 3. Repository public interface EmployeeRepository extends CrudRepository\u0026lt;Employee, Long\u0026gt; { List\u0026lt;EmployeeSalary\u0026gt; findBy(); List\u0026lt;EmployeeSalary\u0026gt; findByDept(String dept); } Interface Based Nested Projections 1. Entities @Entity public class Employee { @Id @GeneratedValue private Integer id; private String name; @ManyToOne(cascade = CascadeType.ALL) private Department department; private int salary; ............. } @Entity public class Department { @Id @GeneratedValue private Integer id; private String deptName; private String location; ............. } 2. Defining Projections public interface EmployeeInfo { String getName(); int getSalary(); DeptInfo getDepartment(); interface DeptInfo { String getDeptName(); } } 3. Repository public interface EmployeeRepository extends CrudRepository\u0026lt;Employee, Long\u0026gt; { List\u0026lt;EmployeeInfo\u0026gt; findBy(); List\u0026lt;EmployeeInfo\u0026gt; findBySalaryBetween(int salaryMin, int salaryMax); List\u0026lt;EmployeeInfo\u0026gt; findByDepartmentLocation(String location); } Open Projections 1. Entities @Entity public class Employee { @Id @GeneratedValue private Integer id; private String name; @ManyToOne(cascade = CascadeType.ALL) private Department department; private int salary; ............. } @Entity public class Department { @Id @GeneratedValue private Integer id; private String deptName; private String location; ............. } 2. Open Projection interface public interface EmployeeInfo { @Value(\u0026#34;#{target.name+\u0026#39; (\u0026#39;+ target.department.deptName+\u0026#39; dept)\u0026#39;}\u0026#34;) String getDisplayString(); @Value(\u0026#34;#{args[0]+\u0026#39;: \u0026#39;+target.name+\u0026#39;, \u0026#39;+args[1]+\u0026#39;: \u0026#39;+ \u0026#34; + \u0026#34;target.department.deptName+\u0026#39;, \u0026#39;+target.department.location}\u0026#34;) String getDetailedString(String labelName, String labelDept); } 3. Repository public interface EmployeeRepository extends CrudRepository\u0026lt;Employee, Long\u0026gt; { List\u0026lt;EmployeeInfo\u0026gt; findBy(); } Projections Using Default Methods 1. Entities @Entity public class Employee { @Id @GeneratedValue private Integer id; private String name; @ManyToOne(cascade = CascadeType.ALL) private Department department; private int salary; ............. } @Entity public class Department { @Id @GeneratedValue private Integer id; private String deptName; private String location; ............. } 2. Projection interface using default method public interface EmployeeInfo { String getName(); Department getDepartment(); default String getDisplayString() { return String.format(\u0026#34;Name: %s, Dept: %s\u0026#34;, getName(), getDepartment().getDeptName()); } } 3.Repository public interface EmployeeRepository extends CrudRepository\u0026lt;Employee, Long\u0026gt; { List\u0026lt;EmployeeInfo\u0026gt; findBy(); } Invoking Bean Methods from Projections\u0026rsquo; SpEL expressions 1. Entities @Entity public class Employee { @Id @GeneratedValue private Integer id; private String name; @ManyToOne(cascade = CascadeType.ALL) private Department department; private int salary; ............. } @Entity public class Department { @Id @GeneratedValue private Integer id; private String deptName; private String location; ............. } 2. The Bean @Component public class EmployeeInfoBean { public String getDisplayString(Employee employee) { return String.format(\u0026#34;%s (%s)\u0026#34;, employee.getName(), employee.getDepartment().getDeptName()); } public String getDetailedString(Employee employee, String labelName, String labelDept) { return String.format(\u0026#34;%s: %s, %s: %s, %s\u0026#34;, labelName, employee.getName(), labelDept, employee.getDepartment().getDeptName(), employee.getDepartment().getLocation()); } } 3. Projection interface public interface EmployeeInfo { @Value(\u0026#34;#{@employeeInfoBean.getDisplayString(target)}\u0026#34;) String getDisplayString(); @Value(\u0026#34;#{@employeeInfoBean.getDetailedString(target, args[0], args[1])}\u0026#34;) String getDetailedString(String labelName, String labelDept); } Class Based Projections 1. Entity @Entity public class Employee{ private @Id @GeneratedValue Long id; private String name; private String dept; private int salary; ............. } 2. Defining class-based projection public class EmployeeInfo { private String name; private int salary; public EmployeeInfo(String name, int salary) { this.name = name; this.salary = salary; } ............. } 3. Repository public interface EmployeeRepository extends CrudRepository\u0026lt;Employee, Long\u0026gt; { List\u0026lt;EmployeeInfo\u0026gt; findBy(); List\u0026lt;EmployeeInfo\u0026gt; findByDept(String dept); } Dynamic Projections 1. Entity @Entity public class Employee{ private @Id @GeneratedValue Long id; private String name; private String dept; private int salary; private String phone; ............. } 2. Repository public interface EmployeeRepository extends CrudRepository\u0026lt;Employee, Long\u0026gt; { \u0026lt;T\u0026gt; List\u0026lt;T\u0026gt; findByDept(String dept, Class\u0026lt;T\u0026gt; type); } 3. Projection classes public class SalaryInfo { private String name; private int salary; public SalaryInfo(String name, int salary) { this.name = name; this.salary = salary; } ............. } public class ContactInfo { private String name; private String phone; public ContactInfo(String name, String phone) { this.name = name; this.phone = phone; } ............. } 4. Example client @Component public class ExampleClient { @Autowired private EmployeeRepository repo; public void run() { List\u0026lt;Employee\u0026gt; employees = createEmployees(); repo.saveAll(employees); System.out.println(\u0026#34; -- finding all employees --\u0026#34;); Iterable\u0026lt;Employee\u0026gt; all = repo.findAll(); all.forEach(System.out::println); System.out.println(\u0026#34; -- finding SalaryInfo for IT dept --\u0026#34;); List\u0026lt;SalaryInfo\u0026gt; list = repo.findByDept(\u0026#34;IT\u0026#34;, SalaryInfo.class); list.forEach(System.out::println); System.out.println(\u0026#34; -- finding ContactInfo for IT dept --\u0026#34;); List\u0026lt;ContactInfo\u0026gt; list2 = repo.findByDept(\u0026#34;IT\u0026#34;, ContactInfo.class); list2.forEach(System.out::println); } private List\u0026lt;Employee\u0026gt; createEmployees() { return Arrays.asList( Employee.create(\u0026#34;Diana\u0026#34;, \u0026#34;Admin\u0026#34;, 3000, \u0026#34;111-111-111\u0026#34;), Employee.create(\u0026#34;Mike\u0026#34;, \u0026#34;IT\u0026#34;, 1000, \u0026#34;222-222-222\u0026#34;), Employee.create(\u0026#34;Rose\u0026#34;, \u0026#34;Admin\u0026#34;, 4000, \u0026#34;333-333-333\u0026#34;), Employee.create(\u0026#34;Sara\u0026#34;, \u0026#34;Admin\u0026#34;, 3500, \u0026#34;444-444-444\u0026#34;), Employee.create(\u0026#34;Tanaka\u0026#34;, \u0026#34;IT\u0026#34;, 3000, \u0026#34;555-555-555\u0026#34;), Employee.create(\u0026#34;Charlie\u0026#34;, \u0026#34;IT\u0026#34;, 450, \u0026#34;666-666-666\u0026#34;) ); } } ","permalink":"http://localhost:1313/posts/spring-data-jpa-projections/","summary":"Spring Data Jpa - Projections","title":"Spring Data Jpa - Projections"},{"content":"例子 @WebMvcTest(AuthController.class) @AutoConfigureMockMvc @ContextConfiguration(classes = {AuthController.class}) class AuthControllerTest { @Autowired private MockMvc mockMvc; @Autowired private ObjectMapper objectMapper; @MockBean private AuthService authService; @Test @WithMockUser void loginPassword() throws Exception { Faker faker = new Faker(); Mockito.when(authService.loginPassword(Mockito.any(PasswordLogin.class))) .thenReturn(new UserToken(true, faker.random().hex(32), faker.random().hex(8))); mockMvc.perform( post(\u0026#34;/api/{version}/auth/login\u0026#34;, \u0026#34;v1\u0026#34;) .with(csrf()) .contentType(MediaType.APPLICATION_JSON) .accept(MediaType.APPLICATION_JSON) .content(objectMapper.writeValueAsString( new PasswordLogin().setPassword(faker.random().hex(8)).setUsername(faker.random().hex(8)) )) ) .andDo(print()) .andExpect(status().isOk()) .andExpect(jsonPath(\u0026#34;$.code\u0026#34;, is(200))); } } 问题汇总 1. java.lang.IllegalStateException: Failed to load ApplicationContext @WebMvcTest(AuthController.class) @AutoConfigureMockMvc @ContextConfiguration(classes = {AuthController.class}) //required class AuthControllerTest { ... } 2. Response Status 403，跨域问题 ... import static org.springframework.security.test.web.servlet.request.SecurityMockMvcRequestPostProcessors.csrf; ... mockMvc.perform( post(\u0026#34;/api/{version}/auth/login\u0026#34;, \u0026#34;v1\u0026#34;) .with(csrf()) //required .contentType(MediaType.APPLICATION_JSON) .accept(MediaType.APPLICATION_JSON) .content(objectMapper.writeValueAsString( new PasswordLogin().setPassword(faker.random().hex(8)).setUsername(faker.random().hex(8)) )) ) .andDo(print()) .andExpect(status().isOk()) .andExpect(jsonPath(\u0026#34;$.code\u0026#34;, is(200))); 3. Response Status 401 Unauthorized @Test @WithMockUser //required void loginPassword() throws Exception { ... } ","permalink":"http://localhost:1313/posts/spring-mvc-unit-test-with-spring-security/","summary":"Spring Mvc Unit Test With Spring Security","title":"Spring Mvc Unit Test With Spring Security"},{"content":"准备 Spring Boot 的可以执行 jar 包叫 bootJar，用于依赖的 Plain jar 叫 jar 在项目设置中添加两个 Actions secrets USERNAME：GitHub 用户名 GITHUB_TOKEN：GitHub 的 token，有读写删 packages 的权限 Gradle Config plugins { ... id \u0026#39;maven-publish\u0026#39; } ... bootJar { enabled = false archiveClassifier = \u0026#39;boot\u0026#39; } jar { enabled = true archiveClassifier = \u0026#39;\u0026#39; } publishing { repositories { maven { name = \u0026#34;GitHubPackages\u0026#34; url = uri(\u0026#34;https://maven.pkg.github.com/xutingzhou/gradle-lib-demo\u0026#34;) credentials { username = System.getenv(\u0026#34;USERNAME\u0026#34;) password = System.getenv(\u0026#34;GITHUB_TOKEN\u0026#34;) } } } publications { gpr(MavenPublication) { artifact jar //Spring Boot 的用于依赖 jar //artifact bootJar //Spring Boot 的可执行 jar } } } action.yml name: Publish package to GitHub Packages on: release: types: [created] jobs: publish: runs-on: ubuntu-latest steps: - uses: actions/checkout@v2 - uses: actions/setup-java@v2 with: java-version: 11 distribution: adopt - name: Validate Gradle wrapper uses: gradle/wrapper-validation-action@v1 - name: Make gradlew executable run: chmod +x ./gradlew - name: Publish package uses: gradle/gradle-build-action@v2 with: arguments: publish env: USERNAME: ${{ secrets.USERNAME }} GITHUB_TOKEN: ${{ secrets.PUBLISH_TOKEN }} 需要将 gradlew 设置可执行，不然会报错 - name: Make gradlew executable run: chmod +x ./gradlew 报错信息\n/home/runner/work/\\_temp/cf1a2363-0c16-47df-b928-cfef31860ce6.sh: line 1: ./gradlew: Permission denied 或者 Error: Gradle script \u0026#39;/home/runner/work/gradle-lib-demo/gradle-lib-demo/gradlew\u0026#39; is not executable. 默认打包用于依赖的 jar 的命名会添加 plain，需要将命名中的 plain 去掉，才能在引用依赖的时候正确下载 jar 包 jar { archiveClassifier = \u0026#39;\u0026#39; } 参考 Publishing Java packages with Gradle Gradle Build Action Spring Boot Gradle Plugin Reference Guide ","permalink":"http://localhost:1313/posts/publish-jar-with-github-action/","summary":"使用 GitHub Action 自动发布 Spring Boot 的 jar 包","title":"使用 GitHub Action 自动发布 Spring Boot 的 jar 包"},{"content":"官网 一个为 Dart 而生，可预测和管理状态的库。https://bloclibrary.dev\n为什么要用 将展示层的代码与业务逻辑分开\n设计时考虑到了三个核心价值 1. 简单 易于理解，可供技能水平不同的开发人员使用。\n2. 强劲 通过将它们组成更小的组件，帮助制作出色而复杂的应用程序。\n3. 可测试 轻松测试应用程序的各个方面，以便我们可以自信地进行迭代。\nbloc 核心思想 流（Streams) 流（Streams) 是一系列异步的数据。Dart 官方文档\nCubit Bloc Cubit vs. Bloc Cubit 的优势 简单，更容易理解，涉及的代码更少\n创建 Cubit 时，只需要定义状态和改变状态的函数。 创建 Bloc 时，必须定义状态、事件和 EventHandler 实现。 Bloc 的优势 可追溯性 知道状态变化的顺序以及触发这些变化的确切原因。对于对于应用程序功能至关重要的状态，使用更多事件驱动的方法来捕获状态变化之外的所有事件可能会非常有益 高级的事件转换 需要利用反应性运算符，例如：buffer, debounceTime, throttle 等。 如果仍然不确定要使用哪种，请从 Cubit 开始，然后可以根据需要将其重构或放大为 Bloc。\nFlutter Bloc 的核心理念 Bloc Widgets BlocBuilder 在接收到新的状态 (State) 时处理构建部件。 BlocSelector 和 BlocBuilder 类似的组件，可以选择一个基于当前 bloc 状态的新值来过滤更新。如果所选值不更改，则会阻止不必要的构建。 BlocProvider 可通过 BlocProvider.of\u0026lt;T\u0026gt;(context) 向其子级提供 bloc。 使用 BlocProvider 来创建新的 blocs，提供给子树。 BlocProvider 默认在需要的时候创建 bloc。lazy 设置为 false，强制立即创建。 MultiBlocProvider 将多个BlocProvider部件合并为一个。 BlocListener 响应该状态 (state) 的变化。 应用于每次状态更改都需要发生一次的功能，例如导航，显示 SnackBar，显示 Dialog 等。 MultiBlocListener 将多个BlocListener部件合并为一个。 BlocConsumer 对新状态 (State) 做出反应。 仅在有必要重建 UI 并执行其他反应来声明 bloc 中的状态 (State) 更改时，才应使用 BlocConsumer。 RepositoryProvider 可通过 RepositoryProvider.of \u0026lt;T\u0026gt;（context) 向其子级提供存储库。 BlocProvider 用于提供 bloc，而 RepositoryProvider 仅用于存储库。 MultiRepositoryProvider 将多个 RepositoryProvider 部件 (widgets) 合并为一个。 架构 数据层（Data Layer) 数据层的责任是从一个或多个数据源或库中检索/处理数据。 是应用程序的最低层，并且与数据库，网络请求和其他异步数据源进行交互。 数据提供者（Data Provider) 数据提供者的责任是提供原始数据。数据提供者所提供的数据应该是能在各个语言间通用。 数据源/库（Repository) 存储库层是与 Bloc 层进行通信的一个或多个数据提供程序的包装。可以与多个数据提供者进行交互，并对数据执行转换，然后再将结果传递给业务逻辑层。 Bloc 业务逻辑层 (Business Logic Layer) Bloc 层的职责是以新状态（State) 响应表示层 (Presentation) 的事件 (Event)。Bloc 层可以依赖一个或多个存储库来检索建立应用程序状态 (State) 所需的数据。 Bloc 和 Bloc 之间的交流 每个 bloc 都有一个状态流（Stream)，其他 bloc 可以订阅该状态流，以便对 bloc 内部的变化做出反应。 表现层（Presentation Layer) UI 表现层的职责是弄清楚如何基于一个或多个 bloc 的状态（State) 进行渲染。另外，它应该处理用户输入和应用程序生命周期事件。 命名惯例 事件（Event) 事件应以过去时来命名，因为从 bloc 的角度来看，事件是已经发生的事情。\n命名状态（State) 状态应该是名词，因为状态只是特定时间点的快照。\n项目结构参考案例 快速建包结构 flutter create --template=package package_name brianegan/flutter_architecture_samples flutter_shopping_cart TDD Clean Architecture for Flutter ","permalink":"http://localhost:1313/posts/learn-flutter-bloc/","summary":"学习 Flutter Bloc","title":"学习 Flutter Bloc"},{"content":"准备 Google TV 网络畅通的路由器 激活 我以为连着 VPN 就行了，发现连不上 WIFI，网上查了下，说是第一次要访问 time.android.com，走的是 udp，我把 VPN 改成 UDP 的，还是不行，就用了另外一种方法，在路由器上把 time.android.com 指向阿里的 ntp 服务器 203.107.6.88，设置好了 ping 一下，没问题，就开始设置，一路畅通。\nDNSMasq Local Network\n","permalink":"http://localhost:1313/posts/activate-google-tv/","summary":"激活 Google TV","title":"激活 Google TV"}]